{"version":3,"sources":["../../src/utils/index.ts","../../src/types.ts","../../src/moment-types/moment-subset.ts","../../src/calendar-context.tsx","../../src/Toolbar.tsx","../../src/render-weekdays.tsx","../../src/render-avail-slots.tsx","../../src/render-day-cell.tsx","../../src/render-day-cells.tsx","../../src/MonthlyAvailabilityCalendar.tsx","../../src/AvailabilityCalendar.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["createUtils","moment","interval","datesEqual","d1","d2","blockOutPeriods","msInHour","blockOutPeriodsTz","shifted","ranges","r","range","i","foldedRangeIndex","foldedRange","filtered","a","b","rotateRangesByms","now","tzNow","Date","timeZone","providerTimeZone","offsetRoundedToNearestHour","Math","console","calcOffsetFromProviderTimeZoneMs","res","periodStartRoundedToDayMs","periodStart","periodEndRoundedToDayMs","periodEnd","period","hourStart","hourEnd","minuteStart","minuteEnd","day","startDate","endDate","isBlockout","formatAsMonth","formatAsDateWithTime","formatAsDateJustTime","formatAsDate","shouldHideWeek","selectedDate","sameWeek","week","viewingDayAvailabilities","shouldShowWeek","availByIndex","days","d","hasAvail","avails","addBlockOutBookings","availabilitiesFromBookings","periodStartMs","roundToHour","ms","periodStartArg","booking","lastAvailability","bookingStartMs","bookingEndMs","saveEndDate","toStartAndEnd","monthRangeForDate","start","end","monthDaysForDate","startOfMonth","endOfMonth","startOfWeek","numDays","endOfWeek","weeks","numWeeks","w","j","chunkify","endMs","msRounded","chunk","intervalLengthMs","defaultTheme","dayClassBase","dayClassSelected","dayClassHasAvailability","dayClassDefault","slotsContainerStyleShow","transition","transform","slotsContainerStyleHide","slotContainerCloseClass","slotButtonClass","toolBarStyle","flexWrap","width","minHeight","toolBarButtonsContainerClass","toolBarButtonClass","toolBarLabelClass","momentSubsetStub","format","Error","startOf","endOf","add","diff","toDate","CalendarContext","React","utils","theme","useCalendarContext","useContext","CalendarContextProvider","children","useMemo","value","navigate","Toolbar","messages","localizer","label","onNavigate","style","className","role","type","onClick","disabled","weekdays","RenderAvailSlots","handleUnselect","onAvailabilitySelected","show","slotStepMs","slotLengthMs","outline","durationMinutes","AddBookingFromAvailabilitySlots","slots","key","marginBottom","minWidth","s","RenderDayCell","date","dayIndexInWeek","weekIndexInCalRange","availsByIndex","handleSelected","dayIndexInCalRange","cursor","border","height","display","justifyContent","alignItems","RenderDayCells","renderDayCell","flexDirection","MonthlyAvailabilityCalendar","availabilities","renderAvailSlots","renderDayCells","useState","setSelectedDate","useEffect","weekday","showWeek","AvailabilityCalendarComp","initialDate","bookings","onCalRangeChange","calRange","setCalRange","setDate","lastCalRange","useRef","startAndEnd","resourceId","today","newDate","previous","next","AvailabilityCalendar","props","App","log","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.98bb3bee.chunk.js","sourcesContent":["import {\r\n  Range,\r\n  MsSinceMidnightRange,\r\n  AvailabilityEvent,\r\n  Booking,\r\n} from '../types';\r\nimport { MomentCtrFunc } from '../moment-types/moment-subset';\r\n\r\nexport function createUtils(moment: MomentCtrFunc) {\r\n  function intervalLengthMs(interval: AvailabilityEvent) {\r\n    return interval.endDate.getTime() - interval.startDate.getTime();\r\n  }\r\n\r\n  function chunkify(\r\n    intervals: AvailabilityEvent[],\r\n    chunkLenMs: number,\r\n    stepLenMs: number\r\n    // shouldMerge = false\r\n  ) {\r\n    // const merged = shouldMerge ? mergeIntervals(intervals) : intervals;\r\n    const res: AvailabilityEvent[] = [];\r\n    for (const interval of intervals) {\r\n      const endMs = interval.endDate.getTime();\r\n      for (let ms = interval.startDate.getTime(); ms < endMs; ms += stepLenMs) {\r\n        // const msRounded = Math.floor(ms / (msInHour / 2.0)) * (msInHour / 2.0);\r\n        const msRounded = ms;\r\n        const chunk = {\r\n          startDate: new Date(msRounded),\r\n          endDate: new Date(Math.min(endMs, msRounded + chunkLenMs)),\r\n        };\r\n        if (intervalLengthMs(chunk) >= chunkLenMs) {\r\n          res.push(chunk);\r\n        }\r\n      }\r\n      // if (res.length > 0 && intervalLengthMs(res[res.length - 1]) < chunkLenMs) {\r\n      //   const last = res.pop();\r\n      // if (res.length > 0) {\r\n      //   // append the too-short last chunk to previous chunk if it's there\r\n      //   res[res.length - 1].endDate = (last as Interval).endDate;\r\n      // }\r\n      // }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  const msInDay = 24 * 60 * 60 * 1000;\r\n  const msInHour = 1 * 60 * 60 * 1000;\r\n  const msInMinute = 1 * 60 * 1000;\r\n  const minuteInHour = 60;\r\n\r\n  function rotateRangesByms(ranges: MsSinceMidnightRange[], ms: number) {\r\n    // make sure ranges are not overlapping\r\n    const shifted = ranges.map(r => [\r\n      (r[0] + ms) % msInDay,\r\n      (r[1] + ms) % msInDay,\r\n    ]);\r\n\r\n    // if the new \"midnight\" happens in the middle of a range, break it into 2\r\n    const foldedRangeIndices = shifted\r\n      .map((range, i) => (range[1] < range[0] ? i : -1))\r\n      .filter(i => i >= 0);\r\n    for (const foldedRangeIndex of foldedRangeIndices) {\r\n      const foldedRange = shifted[foldedRangeIndex];\r\n      shifted[foldedRangeIndex] = [-1, -1]; // mark for deletion (do not disturb indices)\r\n      shifted.push([foldedRange[0], msInDay]); //start till midnight\r\n      shifted.push([0, foldedRange[1]]); // beginning-of-day till end\r\n    }\r\n\r\n    const filtered = shifted.filter(r => r[0] >= 0);\r\n\r\n    filtered.sort((a, b) => a[0] - b[0]);\r\n\r\n    return filtered;\r\n  }\r\n\r\n  function calcOffsetFromProviderTimeZoneMs(providerTimeZone: string) {\r\n    if (!providerTimeZone) return 0;\r\n\r\n    const now = new Date();\r\n    var tzNow = new Date(\r\n      now.toLocaleString('en-US', {\r\n        timeZone: providerTimeZone,\r\n      })\r\n    );\r\n    const offsetRoundedToNearestHour =\r\n      Math.floor((tzNow.getTime() - now.getTime()) / msInHour + 0.5) * msInHour;\r\n    console.log(\r\n      'TZ OFFSET ',\r\n      providerTimeZone,\r\n      ':',\r\n      offsetRoundedToNearestHour\r\n    );\r\n    return offsetRoundedToNearestHour;\r\n  }\r\n\r\n  const ms_in_hour = 60 * 60 * 1000;\r\n\r\n  function roundToHour(ms: number) {\r\n    return Math.floor(ms / ms_in_hour) * ms_in_hour;\r\n  }\r\n\r\n  function formatAsDate(date: Date) {\r\n    return moment(date).format('ddd, MMM Do YYYY');\r\n  }\r\n\r\n  function formatAsDateWithTime(date: Date) {\r\n    return moment(date).format('ddd, MMM Do h:mma');\r\n  }\r\n\r\n  function formatAsDateJustTime(date: Date) {\r\n    return moment(date).format('h:mma');\r\n  }\r\n\r\n  function formatAsMonth(date: Date) {\r\n    return moment(date).format('MMM YYYY');\r\n  }\r\n\r\n  function availByIndex(days: Date[], avails: AvailabilityEvent[]) {\r\n    return (days || []).map(d => ({\r\n      hasAvail: avails.some(a => datesEqual(a.startDate, d)),\r\n    }));\r\n  }\r\n\r\n  function sameWeek(d1: Date, d2: Date) {\r\n    return datesEqual(\r\n      moment(d1)\r\n        .startOf('week')\r\n        .toDate(),\r\n      moment(d2)\r\n        .startOf('week')\r\n        .toDate()\r\n    );\r\n  }\r\n\r\n  function datesEqual(d1: Date, d2: Date) {\r\n    return (\r\n      d1 &&\r\n      d2 &&\r\n      d1.getFullYear() === d2.getFullYear() &&\r\n      d1.getMonth() === d2.getMonth() &&\r\n      d1.getDate() === d2.getDate()\r\n    );\r\n  }\r\n\r\n  function monthDaysForDate(date: Date) {\r\n    const startOfMonth = moment(date).startOf('month');\r\n    const endOfMonth = moment(date).endOf('month');\r\n    const startOfWeek = startOfMonth.startOf('week');\r\n    const endOfWeek = endOfMonth.endOf('week');\r\n    const numDays = endOfWeek.diff(startOfWeek, 'days') + 1;\r\n\r\n    const weeks = [];\r\n    const days = [];\r\n    const d = startOfWeek;\r\n\r\n    const numWeeks = Math.floor(numDays / 7);\r\n    for (let i = 0; i < numWeeks; ++i) {\r\n      const w: Date[] = [];\r\n      weeks.push(w);\r\n      for (let j = 0; j < 7; ++j) {\r\n        w.push(d.toDate());\r\n        days.push(d.toDate());\r\n        d.add(1, 'day');\r\n      }\r\n    }\r\n\r\n    return { weeks, days };\r\n  }\r\n\r\n  function shouldShowWeek(\r\n    selectedDate: Date | null,\r\n    week: Date[],\r\n    viewingDayAvailabilities: AvailabilityEvent[]\r\n  ) {\r\n    return (\r\n      !!selectedDate &&\r\n      sameWeek(selectedDate, week[0]) &&\r\n      viewingDayAvailabilities.length > 0\r\n    );\r\n  }\r\n\r\n  function shouldHideWeek(\r\n    selectedDate: Date | null,\r\n    week: Date[],\r\n    viewingDayAvailabilities: AvailabilityEvent[]\r\n  ) {\r\n    return (\r\n      selectedDate &&\r\n      !sameWeek(selectedDate, week[0]) &&\r\n      viewingDayAvailabilities.length > 0\r\n    );\r\n  }\r\n\r\n  function addBlockOutBookings(\r\n    blockOutPeriods: MsSinceMidnightRange[],\r\n    provideTimeZone: string,\r\n    bookings: Booking[],\r\n    periodStart: Date,\r\n    periodEnd: Date\r\n  ) {\r\n    if (blockOutPeriods.length === 0) {\r\n      blockOutPeriods = [[msInHour * 23 + 59 * 60 * 1000, msInHour * 24]];\r\n    }\r\n    const tzOffsetMs = calcOffsetFromProviderTimeZoneMs(provideTimeZone);\r\n    const blockOutPeriodsTz = rotateRangesByms(blockOutPeriods, tzOffsetMs);\r\n    const res = [...bookings];\r\n    const periodStartRoundedToDayMs = new Date(\r\n      periodStart.getFullYear(),\r\n      periodStart.getMonth(),\r\n      periodStart.getDate()\r\n    ).getTime();\r\n    const periodEndRoundedToDayMs = new Date(\r\n      periodEnd.getFullYear(),\r\n      periodEnd.getMonth(),\r\n      periodEnd.getDate()\r\n    ).getTime();\r\n    for (\r\n      let i = periodStartRoundedToDayMs;\r\n      i <= periodEndRoundedToDayMs;\r\n      i = i + msInDay\r\n    ) {\r\n      for (const period of blockOutPeriodsTz) {\r\n        const hourStart = Math.floor(period[0] / msInHour);\r\n        const hourEnd = Math.floor(period[1] / msInHour);\r\n        const minuteStart = Math.floor(period[0] / msInMinute) % minuteInHour;\r\n        const minuteEnd = Math.floor(period[1] / msInMinute) % minuteInHour;\r\n        const day = new Date(i);\r\n        res.push({\r\n          startDate: new Date(\r\n            day.getFullYear(),\r\n            day.getMonth(),\r\n            day.getDate(),\r\n            hourStart,\r\n            minuteStart\r\n          ),\r\n          endDate: new Date(\r\n            day.getFullYear(),\r\n            day.getMonth(),\r\n            day.getDate(),\r\n            hourEnd,\r\n            minuteEnd\r\n          ),\r\n          isBlockout: true,\r\n        });\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function availabilitiesFromBookings(\r\n    blockOutPeriods: MsSinceMidnightRange[],\r\n    providerTimeZone: string,\r\n    bookings: Booking[],\r\n    now: Date,\r\n    periodStartArg: Date,\r\n    periodEnd: Date\r\n  ) {\r\n    const periodStartMs = Math.max(\r\n      roundToHour(now.getTime()) + ms_in_hour,\r\n      periodStartArg.getTime()\r\n    );\r\n    const periodStart = new Date(periodStartMs);\r\n    if (periodEnd.getTime() <= periodStart.getTime()) {\r\n      return [];\r\n    }\r\n    const withBlockouts = addBlockOutBookings(\r\n      blockOutPeriods,\r\n      providerTimeZone,\r\n      bookings,\r\n      periodStart,\r\n      periodEnd\r\n    );\r\n    const sorted = withBlockouts.sort(\r\n      (a, b) => a.startDate.getTime() - b.startDate.getTime()\r\n    );\r\n    // Mark the whole period available to start\r\n    const res: AvailabilityEvent[] = [\r\n      {\r\n        startDate: periodStart,\r\n        endDate: periodEnd,\r\n      },\r\n    ];\r\n    for (const booking of sorted) {\r\n      const lastAvailability = res[res.length - 1];\r\n      const bookingStartMs = booking.startDate.getTime();\r\n      const bookingEndMs = booking.endDate.getTime();\r\n      if (\r\n        !booking.startDate ||\r\n        !booking.endDate ||\r\n        bookingStartMs >= bookingEndMs\r\n      ) {\r\n        continue;\r\n      }\r\n      if (bookingStartMs < lastAvailability.startDate.getTime()) {\r\n        // move lastAvailability start date to be past booking end\r\n        lastAvailability.startDate = new Date(\r\n          Math.max(lastAvailability.startDate.getTime(), bookingEndMs)\r\n        );\r\n      } else if (bookingStartMs < lastAvailability.endDate.getTime()) {\r\n        const saveEndDate = lastAvailability.endDate;\r\n        // cut off lastAvailability before booking start\r\n        lastAvailability.endDate = new Date(bookingStartMs);\r\n        if (bookingEndMs < saveEndDate.getTime()) {\r\n          //create new availability after booking end\r\n          res.push({ startDate: new Date(bookingEndMs), endDate: saveEndDate });\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function toStartAndEnd(range: Range) {\r\n    const res = {\r\n      startDate:\r\n        (range as {\r\n          start: Date;\r\n        }).start || (range as Date[])[0],\r\n      endDate:\r\n        (range as {\r\n          end: Date;\r\n        }).end || (range as Date[])[(range as Date[]).length - 1],\r\n    };\r\n    if (res.startDate.getTime() === res.endDate.getTime()) {\r\n      res.endDate = new Date(res.endDate.getTime() + msInDay);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  function monthRangeForDate(d: Date) {\r\n    return {\r\n      start: moment(d)\r\n        .startOf('month')\r\n        .toDate(),\r\n      end: moment(d)\r\n        .endOf('month')\r\n        .toDate(),\r\n    };\r\n  }\r\n\r\n  return {\r\n    msInHour,\r\n    datesEqual,\r\n    formatAsMonth,\r\n    formatAsDateWithTime,\r\n    formatAsDateJustTime,\r\n    formatAsDate,\r\n    shouldHideWeek,\r\n    shouldShowWeek,\r\n    availByIndex,\r\n    addBlockOutBookings,\r\n    availabilitiesFromBookings,\r\n    toStartAndEnd,\r\n    monthRangeForDate,\r\n    monthDaysForDate,\r\n    chunkify,\r\n  };\r\n}\r\n","import { MomentCtrFunc } from './moment-types/moment-subset';\r\nimport { createUtils } from './utils';\r\nimport { CSSProperties } from 'react';\r\n\r\nexport interface CalendarTheme {\r\n  dayClassBase: string;\r\n  dayClassSelected: string;\r\n  dayClassHasAvailability: string;\r\n  dayClassDefault: string;\r\n\r\n  slotsContainerStyleShow: CSSProperties;\r\n  slotsContainerStyleHide: CSSProperties;\r\n  slotContainerCloseClass: string;\r\n  slotButtonClass: string;\r\n\r\n  toolBarStyle: CSSProperties;\r\n  toolBarButtonsContainerClass: string;\r\n  toolBarButtonClass: string;\r\n  toolBarLabelClass: string;\r\n}\r\n\r\nexport interface CalendarThemeProp {\r\n  dayClassBase?: string;\r\n  dayClassSelected?: string;\r\n  dayClassHasAvailability?: string;\r\n  dayClassDefault?: string;\r\n\r\n  slotsContainerStyleShow?: CSSProperties;\r\n  slotsContainerStyleHide?: CSSProperties;\r\n  slotContainerCloseClass?: string;\r\n  slotButtonClass?: string;\r\n\r\n  toolBarStyle?: CSSProperties;\r\n  toolBarButtonsContainerClass?: string;\r\n  toolBarButtonClass?: string;\r\n  toolBarLabelClass?: string;\r\n}\r\n\r\nexport const defaultTheme: CalendarTheme = {\r\n  dayClassBase: 'rounded-circle',\r\n  dayClassSelected: 'border-primary',\r\n  dayClassHasAvailability: 'border-info',\r\n  dayClassDefault: 'border border-default',\r\n\r\n  slotsContainerStyleShow: {\r\n    transition: 'transform 300ms',\r\n    transform: 'scale(1)',\r\n  },\r\n  slotsContainerStyleHide: {\r\n    transition: 'transform 300ms',\r\n    transform: 'scale(0)',\r\n  },\r\n  slotContainerCloseClass: 'close',\r\n  slotButtonClass: 'btn btn-primary',\r\n\r\n  toolBarStyle: {\r\n    flexWrap: 'nowrap',\r\n    width: 350,\r\n    minHeight: 50,\r\n  },\r\n  toolBarButtonsContainerClass: 'border btn-group w-100',\r\n  toolBarButtonClass: 'btn',\r\n  toolBarLabelClass: 'btn btn-link',\r\n};\r\n\r\nexport interface AvailabilityEvent {\r\n  startDate: Date;\r\n  endDate: Date;\r\n}\r\n\r\nexport interface Booking {\r\n  startDate: Date;\r\n  endDate: Date;\r\n}\r\n\r\nexport type NavigateAction = 'PREV' | 'NEXT' | 'TODAY' | 'DATE';\r\nexport interface Navigate {\r\n  [key: string]: NavigateAction;\r\n}\r\n\r\nexport interface ToolBarProps {\r\n  label: string;\r\n  onNavigate: (action: NavigateAction) => any;\r\n  localizer: { messages: { [key: string]: string } };\r\n}\r\n\r\ntype stringOrDate = string | Date;\r\n\r\nexport type Range = Date[] | { start: stringOrDate; end: stringOrDate };\r\n\r\nexport interface AvailabilityCalendarProps {\r\n  moment: MomentCtrFunc;\r\n  theme?: CalendarThemeProp;\r\n  onCalRangeChange?: (range: Range) => any;\r\n  providerTimeZone: string;\r\n  bookings: Booking[];\r\n  initialDate: Date | null;\r\n  onAvailabilitySelected: (e: AvailabilityEvent) => any;\r\n  blockOutPeriods?: MsSinceMidnightRange[];\r\n  slotLengthMs?: number;\r\n  slotStepMs?: number;\r\n\r\n  renderDayCell?: (p: RenderDayCellProps) => JSX.Element | null;\r\n  renderDayCells?: (p: RenderDayCellsProps) => JSX.Element | null;\r\n  renderAvailSlots?: (p: RenderAvailProps) => JSX.Element | null;\r\n}\r\n\r\nexport interface MonthlyAvailabilityCalendarProps {\r\n  availabilities: AvailabilityEvent[];\r\n  date: Date;\r\n  style?: CSSProperties;\r\n  onAvailabilitySelected: (e: AvailabilityEvent) => any;\r\n  slotLengthMs?: number;\r\n  slotStepMs?: number;\r\n\r\n  renderDayCell?: (p: RenderDayCellProps) => JSX.Element | null;\r\n  renderDayCells?: (p: RenderDayCellsProps) => JSX.Element | null;\r\n  renderAvailSlots?: (p: RenderAvailProps) => JSX.Element | null;\r\n}\r\n\r\nexport interface RenderDayCellProps {\r\n  selectedDate: Date | null;\r\n  date: Date;\r\n  dayIndexInWeek: number;\r\n  weekIndexInCalRange: number;\r\n  handleSelected: (d: Date) => any;\r\n  availsByIndex: HasAvail[];\r\n  moment: MomentCtrFunc;\r\n  utils: ReturnType<typeof createUtils>;\r\n  theme: CalendarTheme;\r\n}\r\n\r\nexport interface RenderDayCellsProps {\r\n  week: Date[];\r\n  selectedDate: Date | null;\r\n  weekIndexInCalRange: number;\r\n  handleSelected: (date: Date) => void;\r\n  availsByIndex: {\r\n    hasAvail: boolean;\r\n  }[];\r\n\r\n  renderDayCell?: (p: RenderDayCellProps) => JSX.Element | null;\r\n\r\n  moment: MomentCtrFunc;\r\n  utils: ReturnType<typeof createUtils>;\r\n  theme: CalendarTheme;\r\n}\r\n\r\nexport interface RenderAvailProps {\r\n  viewingDayAvailabilities: AvailabilityEvent[];\r\n  handleUnselect: () => any;\r\n  show: boolean;\r\n  onAvailabilitySelected: (e: AvailabilityEvent) => any;\r\n  slotLengthMs?: number;\r\n  slotStepMs?: number;\r\n\r\n  utils: ReturnType<typeof createUtils>;\r\n  theme: CalendarTheme;\r\n}\r\n\r\nexport interface HasAvail {\r\n  hasAvail: boolean;\r\n}\r\n\r\nexport interface Booking {\r\n  id?: string;\r\n  startDate: Date;\r\n  endDate: Date;\r\n  isBlockout?: boolean;\r\n  resourceId?: number;\r\n}\r\n\r\nexport interface RenderSlotsProps {\r\n  avails: AvailabilityEvent[];\r\n}\r\n\r\nexport type MsSinceMidnightRange = number[];\r\n","declare function moment1(...args: any): MomentSubset;\r\n\r\nexport type MomentCtrFunc = typeof moment1;\r\n\r\ntype RelativeTimeKey =\r\n  | 's'\r\n  | 'ss'\r\n  | 'm'\r\n  | 'mm'\r\n  | 'h'\r\n  | 'hh'\r\n  | 'd'\r\n  | 'dd'\r\n  | 'M'\r\n  | 'MM'\r\n  | 'y'\r\n  | 'yy';\r\ntype CalendarKey =\r\n  | 'sameDay'\r\n  | 'nextDay'\r\n  | 'lastDay'\r\n  | 'nextWeek'\r\n  | 'lastWeek'\r\n  | 'sameElse'\r\n  | string;\r\ntype LongDateFormatKey =\r\n  | 'LTS'\r\n  | 'LT'\r\n  | 'L'\r\n  | 'LL'\r\n  | 'LLL'\r\n  | 'LLLL'\r\n  | 'lts'\r\n  | 'lt'\r\n  | 'l'\r\n  | 'll'\r\n  | 'lll'\r\n  | 'llll';\r\n\r\ninterface Locale {\r\n  calendar(key?: CalendarKey, m?: MomentSubset, now?: MomentSubset): string;\r\n\r\n  longDateFormat(key: LongDateFormatKey): string;\r\n  invalidDate(): string;\r\n  ordinal(n: number): string;\r\n\r\n  preparse(inp: string): string;\r\n  postformat(inp: string): string;\r\n  relativeTime(\r\n    n: number,\r\n    withoutSuffix: boolean,\r\n    key: RelativeTimeKey,\r\n    isFuture: boolean\r\n  ): string;\r\n  pastFuture(diff: number, absRelTime: string): string;\r\n  set(config: Object): void;\r\n\r\n  months(): string[];\r\n  months(m: MomentSubset, format?: string): string;\r\n  monthsShort(): string[];\r\n  monthsShort(m: MomentSubset, format?: string): string;\r\n  monthsParse(monthName: string, format: string, strict: boolean): number;\r\n  monthsRegex(strict: boolean): RegExp;\r\n  monthsShortRegex(strict: boolean): RegExp;\r\n\r\n  week(m: MomentSubset): number;\r\n  firstDayOfYear(): number;\r\n  firstDayOfWeek(): number;\r\n\r\n  weekdays(): string[];\r\n  weekdays(m: MomentSubset, format?: string): string;\r\n  weekdaysMin(): string[];\r\n  weekdaysMin(m: MomentSubset): string;\r\n  weekdaysShort(): string[];\r\n  weekdaysShort(m: MomentSubset): string;\r\n  weekdaysParse(weekdayName: string, format: string, strict: boolean): number;\r\n  weekdaysRegex(strict: boolean): RegExp;\r\n  weekdaysShortRegex(strict: boolean): RegExp;\r\n  weekdaysMinRegex(strict: boolean): RegExp;\r\n\r\n  isPM(input: string): boolean;\r\n  meridiem(hour: number, minute: number, isLower: boolean): string;\r\n}\r\n\r\ninterface Duration {\r\n  clone(): Duration;\r\n\r\n  humanize(withSuffix?: boolean): string;\r\n\r\n  abs(): Duration;\r\n\r\n  as(units: Base): number;\r\n  get(units: Base): number;\r\n\r\n  milliseconds(): number;\r\n  asMilliseconds(): number;\r\n\r\n  seconds(): number;\r\n  asSeconds(): number;\r\n\r\n  minutes(): number;\r\n  asMinutes(): number;\r\n\r\n  hours(): number;\r\n  asHours(): number;\r\n\r\n  days(): number;\r\n  asDays(): number;\r\n\r\n  weeks(): number;\r\n  asWeeks(): number;\r\n\r\n  months(): number;\r\n  asMonths(): number;\r\n\r\n  years(): number;\r\n  asYears(): number;\r\n\r\n  add(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;\r\n  subtract(inp?: DurationInputArg1, unit?: DurationInputArg2): Duration;\r\n\r\n  locale(): string;\r\n  locale(locale: LocaleSpecifier): Duration;\r\n  localeData(): Locale;\r\n\r\n  toISOString(): string;\r\n  toJSON(): string;\r\n\r\n  isValid(): boolean;\r\n\r\n  /**\r\n   * @deprecated since version 2.8.0\r\n   */\r\n  lang(locale: LocaleSpecifier): MomentSubset;\r\n  /**\r\n   * @deprecated since version 2.8.0\r\n   */\r\n  lang(): Locale;\r\n  /**\r\n   * @deprecated\r\n   */\r\n  toIsoString(): string;\r\n}\r\n\r\ntype Base =\r\n  | 'year'\r\n  | 'years'\r\n  | 'y'\r\n  | 'month'\r\n  | 'months'\r\n  | 'M'\r\n  | 'week'\r\n  | 'weeks'\r\n  | 'w'\r\n  | 'day'\r\n  | 'days'\r\n  | 'd'\r\n  | 'hour'\r\n  | 'hours'\r\n  | 'h'\r\n  | 'minute'\r\n  | 'minutes'\r\n  | 'm'\r\n  | 'second'\r\n  | 'seconds'\r\n  | 's'\r\n  | 'millisecond'\r\n  | 'milliseconds'\r\n  | 'ms';\r\n\r\ntype _quarter = 'quarter' | 'quarters' | 'Q';\r\ntype _isoWeek = 'isoWeek' | 'isoWeeks' | 'W';\r\ntype _date = 'date' | 'dates' | 'D';\r\ntype DurationConstructor = Base | _quarter;\r\n\r\ntype StartOf = Base | _quarter | _isoWeek | _date | void; // null\r\n\r\ntype Diff = Base | _quarter;\r\n\r\ninterface MomentInputObject {\r\n  years?: number;\r\n  year?: number;\r\n  y?: number;\r\n\r\n  months?: number;\r\n  month?: number;\r\n  M?: number;\r\n\r\n  days?: number;\r\n  day?: number;\r\n  d?: number;\r\n\r\n  dates?: number;\r\n  date?: number;\r\n  D?: number;\r\n\r\n  hours?: number;\r\n  hour?: number;\r\n  h?: number;\r\n\r\n  minutes?: number;\r\n  minute?: number;\r\n  m?: number;\r\n\r\n  seconds?: number;\r\n  second?: number;\r\n  s?: number;\r\n\r\n  milliseconds?: number;\r\n  millisecond?: number;\r\n  ms?: number;\r\n}\r\n\r\ninterface DurationInputObject extends MomentInputObject {\r\n  quarters?: number;\r\n  quarter?: number;\r\n  Q?: number;\r\n\r\n  weeks?: number;\r\n  week?: number;\r\n  w?: number;\r\n}\r\n\r\ninterface FromTo {\r\n  from: MomentInput;\r\n  to: MomentInput;\r\n}\r\n\r\ntype MomentInput =\r\n  | MomentSubset\r\n  | Date\r\n  | string\r\n  | number\r\n  | (number | string)[]\r\n  | MomentInputObject\r\n  | void; // null | undefined\r\n\r\ntype MomentInputSubset =\r\n  | MomentSubset\r\n  | Date\r\n  | string\r\n  | number\r\n  | (number | string)[]\r\n  | MomentInputObject\r\n  | void; // null | undefined\r\n\r\ntype DurationInputArg1 =\r\n  | Duration\r\n  | number\r\n  | string\r\n  | FromTo\r\n  | DurationInputObject\r\n  | void; // null | undefined\r\ntype DurationInputArg2 = DurationConstructor;\r\ntype LocaleSpecifier = string | MomentSubset | Duration | string[] | boolean;\r\n\r\nexport interface MomentSubset extends Object {\r\n  format(format?: string): string;\r\n\r\n  startOf(unitOfTime: StartOf): MomentSubset;\r\n  endOf(unitOfTime: StartOf): MomentSubset;\r\n\r\n  add(amount?: DurationInputArg1, unit?: DurationInputArg2): MomentSubset;\r\n\r\n  diff(b: MomentInputSubset, unitOfTime?: Diff, precise?: boolean): number;\r\n\r\n  toDate(): Date;\r\n}\r\n\r\nexport const momentSubsetStub: MomentSubset = {\r\n  format: (_format?: string) => {\r\n    throw new Error('not implemented');\r\n  },\r\n\r\n  startOf: (_unitOfTime: StartOf) => {\r\n    throw new Error('not implemented');\r\n  },\r\n  endOf: (_unitOfTime: StartOf) => {\r\n    throw new Error('not implemented');\r\n  },\r\n\r\n  add: (_amount?: DurationInputArg1, _unit?: DurationInputArg2) => {\r\n    throw new Error('not implemented');\r\n  },\r\n\r\n  diff: (_b: MomentInputSubset, _unitOfTime?: Diff, _precise?: boolean) => {\r\n    throw new Error('not implemented');\r\n  },\r\n\r\n  toDate: () => {\r\n    throw new Error('not implemented');\r\n  },\r\n};\r\n","import React, { useContext, useMemo } from \"react\";\r\nimport { createUtils } from \"./utils\";\r\nimport { CalendarTheme, defaultTheme } from \"./types\";\r\nimport { MomentCtrFunc, momentSubsetStub } from \"./moment-types/moment-subset\";\r\n\r\nexport const CalendarContext = React.createContext<{\r\n  moment: MomentCtrFunc;\r\n  utils: ReturnType<typeof createUtils>;\r\n  theme: CalendarTheme;\r\n}>({\r\n  moment: () => momentSubsetStub,\r\n  utils: createUtils(() => momentSubsetStub),\r\n  theme: defaultTheme\r\n});\r\n\r\nexport const useCalendarContext = () => useContext(CalendarContext);\r\n\r\nexport const CalendarContextProvider = ({ moment, theme, children }: any) => {\r\n  const utils = useMemo(() => createUtils(moment), [moment]);\r\n\r\n  return (\r\n    <CalendarContext.Provider\r\n      value={{\r\n        moment,\r\n        utils,\r\n        theme\r\n      }}\r\n    >\r\n      {children}\r\n    </CalendarContext.Provider>\r\n  );\r\n};\r\n","import React from 'react';\r\nimport { Navigate, ToolBarProps } from './types';\r\nimport { useCalendarContext } from './calendar-context';\r\n\r\nconst navigate: Navigate = {\r\n  PREVIOUS: 'PREV',\r\n  NEXT: 'NEXT',\r\n  TODAY: 'TODAY',\r\n  DATE: 'DATE',\r\n};\r\n\r\nexport const Toolbar = ({\r\n  localizer: { messages },\r\n  label,\r\n  onNavigate,\r\n}: ToolBarProps) => {\r\n  const { theme } = useCalendarContext();\r\n  return (\r\n    <div>\r\n      <div style={theme.toolBarStyle}>\r\n        <div className={theme.toolBarButtonsContainerClass} role=\"group\">\r\n          <button\r\n            type=\"button\"\r\n            className={theme.toolBarButtonClass}\r\n            onClick={() => onNavigate(navigate.TODAY)}\r\n          >\r\n            {messages.today}\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className={theme.toolBarButtonClass}\r\n            onClick={() => onNavigate(navigate.PREVIOUS)}\r\n          >\r\n            {messages.previous}\r\n          </button>\r\n          <button\r\n            type=\"button\"\r\n            className={theme.toolBarButtonClass}\r\n            onClick={() => onNavigate(navigate.NEXT)}\r\n          >\r\n            {messages.next}\r\n          </button>\r\n          <button\r\n            disabled\r\n            className={theme.toolBarLabelClass}\r\n            style={{ width: 110 }}\r\n          >\r\n            <span>{label}</span>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\n\r\nconst weekdays = [\"S\", \"M\", \"T\", \"W\", \"Th\", \"F\", \"Sa\"];\r\n\r\nexport const renderWeekdays = () => {\r\n  return (\r\n    <div\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"flex-start\",\r\n        flexWrap: \"nowrap\",\r\n        flexDirection: \"row\"\r\n      }}\r\n    >\r\n      {weekdays.map(weekday => (\r\n        <div\r\n          className=\"border border-default\"\r\n          key={weekday}\r\n          style={{\r\n            height: 50,\r\n            width: 50,\r\n            marginBottom: 10,\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            alignItems: \"center\"\r\n          }}\r\n        >\r\n          {weekday}\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n","import React, { useMemo } from 'react';\r\nimport {\r\n  RenderAvailProps,\r\n  Booking,\r\n  AvailabilityEvent,\r\n  CalendarTheme,\r\n} from './types';\r\nimport { createUtils } from './utils';\r\n\r\nexport const RenderAvailSlots: React.SFC<RenderAvailProps> = ({\r\n  viewingDayAvailabilities,\r\n  handleUnselect,\r\n  onAvailabilitySelected,\r\n  show,\r\n  slotStepMs,\r\n  slotLengthMs,\r\n  utils,\r\n  theme,\r\n}) => {\r\n  return (\r\n    <div\r\n      style={\r\n        show ? theme.slotsContainerStyleShow : theme.slotsContainerStyleHide\r\n      }\r\n    >\r\n      {show && (\r\n        <div className=\"mt-2 mr-1\">\r\n          <button\r\n            type=\"button\"\r\n            className={theme.slotContainerCloseClass}\r\n            aria-label=\"Close\"\r\n            style={{ outline: 'none' }}\r\n            onClick={handleUnselect}\r\n          >\r\n            <span aria-hidden=\"true\">&times;</span>\r\n          </button>\r\n          <AddBookingFromAvailabilitySlots\r\n            theme={theme}\r\n            durationMinutes={60}\r\n            avails={viewingDayAvailabilities}\r\n            onAvailabilitySelected={onAvailabilitySelected}\r\n            slotLengthMs={slotLengthMs}\r\n            slotStepMs={slotStepMs}\r\n            utils={utils}\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport const AddBookingFromAvailabilitySlots = ({\r\n  avails,\r\n  // onAdded,\r\n  slotLengthMs,\r\n  slotStepMs,\r\n  onAvailabilitySelected,\r\n  theme,\r\n  utils,\r\n}: // durationMinutes //duration of the booking to create\r\n{\r\n  avails: Booking[];\r\n  theme: CalendarTheme;\r\n  durationMinutes: number;\r\n  slotLengthMs?: number;\r\n  slotStepMs?: number;\r\n  onAvailabilitySelected: (e: AvailabilityEvent) => any;\r\n  utils: ReturnType<typeof createUtils>;\r\n  // onAdded: () => any;\r\n}) => {\r\n  const { chunkify, msInHour, formatAsDate, formatAsDateJustTime } = utils;\r\n  const slots = useMemo(\r\n    () =>\r\n      chunkify(\r\n        avails.map(a => ({\r\n          startDate: a.startDate,\r\n          endDate: a.endDate,\r\n        })),\r\n        slotLengthMs || 1 * msInHour,\r\n        slotStepMs || 0.5 * msInHour\r\n      ),\r\n    [avails, msInHour, chunkify, slotLengthMs, slotStepMs]\r\n  );\r\n\r\n  return (\r\n    <div>\r\n      <h4>Request Appointment</h4>\r\n      <h5>\r\n        {avails && avails.length > 0 ? formatAsDate(avails[0].startDate) : ''}\r\n      </h5>\r\n      {slots.map((s, i) => (\r\n        <div key={'b_' + i} style={{ marginBottom: 10 }}>\r\n          <button\r\n            className={theme.slotButtonClass}\r\n            disabled={false}\r\n            // variant=\"contained\"\r\n            style={{ minWidth: 200 }}\r\n            onClick={() =>\r\n              onAvailabilitySelected({\r\n                startDate: new Date(s.startDate),\r\n                endDate: new Date(s.endDate),\r\n              })\r\n            }\r\n          >\r\n            {formatAsDateJustTime(new Date(s.startDate))}\r\n          </button>\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport { RenderDayCellProps } from \"./types\";\r\n\r\nexport const RenderDayCell = ({\r\n  date,\r\n  dayIndexInWeek,\r\n  weekIndexInCalRange,\r\n  availsByIndex,\r\n  selectedDate,\r\n  handleSelected,\r\n  moment,\r\n  utils,\r\n  theme\r\n}: RenderDayCellProps) => {\r\n  const dayIndexInCalRange = weekIndexInCalRange * 7 + dayIndexInWeek;\r\n\r\n  return (\r\n    <div\r\n      key={\"d_\" + dayIndexInWeek}\r\n      className={\r\n        theme.dayClassBase +\r\n        \" \" +\r\n        (selectedDate && utils.datesEqual(date, selectedDate)\r\n          ? theme.dayClassSelected\r\n          : availsByIndex[dayIndexInCalRange].hasAvail\r\n          ? theme.dayClassHasAvailability\r\n          : theme.dayClassDefault)\r\n      }\r\n      style={{\r\n        cursor: \"pointer\",\r\n        border:\r\n          selectedDate && utils.datesEqual(date, selectedDate)\r\n            ? \"4px solid\"\r\n            : availsByIndex[dayIndexInCalRange].hasAvail\r\n            ? \"3px solid\"\r\n            : \"\",\r\n        height: 50,\r\n        width: 50,\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\"\r\n      }}\r\n      onClick={() => handleSelected(date)}\r\n    >\r\n      {moment(date).format(\"D\")}\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport { RenderDayCellsProps } from \"./types\";\r\nimport { RenderDayCell } from \"./render-day-cell\";\r\n\r\nexport function RenderDayCells({\r\n  week,\r\n  selectedDate,\r\n  weekIndexInCalRange,\r\n  handleSelected,\r\n  availsByIndex,\r\n  renderDayCell,\r\n  moment,\r\n  utils,\r\n  theme\r\n}: RenderDayCellsProps) {\r\n  renderDayCell = renderDayCell || RenderDayCell;\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"flex-start\",\r\n        flexWrap: \"nowrap\",\r\n        flexDirection: \"row\"\r\n      }}\r\n    >\r\n      {week.map(\r\n        (d, j) =>\r\n          renderDayCell &&\r\n          renderDayCell({\r\n            date: d,\r\n            selectedDate,\r\n            weekIndexInCalRange,\r\n            dayIndexInWeek: j,\r\n            handleSelected,\r\n            availsByIndex,\r\n            moment,\r\n            utils,\r\n            theme\r\n          })\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","import React, { useState, useMemo, useEffect } from 'react';\r\n\r\nimport { renderWeekdays } from './render-weekdays';\r\nimport { MonthlyAvailabilityCalendarProps } from './types';\r\n\r\nimport { RenderAvailSlots } from './render-avail-slots';\r\nimport { RenderDayCells } from './render-day-cells';\r\nimport { useCalendarContext } from './calendar-context';\r\n\r\nexport const MonthlyAvailabilityCalendar = ({\r\n  availabilities,\r\n  onAvailabilitySelected,\r\n  slotLengthMs,\r\n  slotStepMs,\r\n  date,\r\n  style,\r\n  renderAvailSlots,\r\n  renderDayCells,\r\n  renderDayCell,\r\n}: MonthlyAvailabilityCalendarProps) => {\r\n  renderAvailSlots = renderAvailSlots || RenderAvailSlots;\r\n  renderDayCells = renderDayCells || RenderDayCells;\r\n\r\n  const { moment, theme, utils } = useCalendarContext();\r\n\r\n  const [selectedDate, setSelectedDate] = useState<Date | null>(null);\r\n\r\n  useEffect(() => {\r\n    setSelectedDate(null);\r\n  }, [date]);\r\n\r\n  const handleSelected = (date: Date) => {\r\n    if (selectedDate && utils.datesEqual(date, selectedDate)) {\r\n      setSelectedDate(null);\r\n    } else {\r\n      setSelectedDate(date);\r\n    }\r\n  };\r\n\r\n  const handleUnselect = () => {\r\n    setSelectedDate(null);\r\n  };\r\n\r\n  const { days, weeks } = useMemo(() => utils.monthDaysForDate(date), [\r\n    date,\r\n    utils,\r\n  ]);\r\n\r\n  const availsByIndex = useMemo(\r\n    () => utils.availByIndex(days, availabilities),\r\n    [days, availabilities, utils]\r\n  );\r\n\r\n  const viewingDayAvailabilities = useMemo(() => {\r\n    if (selectedDate !== null) {\r\n      return (availabilities || []).filter(({ startDate }) =>\r\n        utils.datesEqual(startDate, selectedDate)\r\n      );\r\n    } else {\r\n      return [];\r\n    }\r\n  }, [selectedDate, availabilities, utils]);\r\n\r\n  return (\r\n    <div style={{ minHeight: 368, ...style }}>\r\n      {/* render weekdays header */}\r\n      {renderWeekdays()}\r\n\r\n      {/* render each week in cal range */}\r\n      {weeks.map((w, i) => {\r\n        const showWeek = utils.shouldShowWeek(\r\n          selectedDate,\r\n          w,\r\n          viewingDayAvailabilities\r\n        );\r\n        const hideWeek = utils.shouldHideWeek(\r\n          selectedDate,\r\n          w,\r\n          viewingDayAvailabilities\r\n        );\r\n        return hideWeek ? null : (\r\n          <React.Fragment key={'w_' + i}>\r\n            {renderDayCells &&\r\n              renderDayCells({\r\n                week: w,\r\n                selectedDate,\r\n                weekIndexInCalRange: i,\r\n                handleSelected,\r\n                availsByIndex,\r\n                renderDayCell,\r\n                moment,\r\n                utils,\r\n                theme,\r\n              })}\r\n            {renderAvailSlots &&\r\n              renderAvailSlots({\r\n                show: showWeek,\r\n                onAvailabilitySelected,\r\n                viewingDayAvailabilities,\r\n                handleUnselect,\r\n                slotLengthMs,\r\n                slotStepMs,\r\n                utils,\r\n                theme,\r\n              })}\r\n          </React.Fragment>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n","import React, { useState, useMemo, useEffect, useRef } from 'react';\r\n\r\n// import { stringOrDate, NavigateAction, View } from \"react-big-calendar\";\r\n\r\nimport { Toolbar } from './Toolbar';\r\n\r\nimport {\r\n  NavigateAction,\r\n  AvailabilityCalendarProps,\r\n  Range,\r\n  defaultTheme,\r\n} from './types';\r\n\r\nimport { MonthlyAvailabilityCalendar } from './MonthlyAvailabilityCalendar';\r\nimport {\r\n  useCalendarContext,\r\n  CalendarContextProvider,\r\n} from './calendar-context';\r\n\r\nconst AvailabilityCalendarComp = ({\r\n  initialDate,\r\n  onAvailabilitySelected,\r\n  blockOutPeriods,\r\n  providerTimeZone,\r\n  bookings,\r\n  onCalRangeChange,\r\n  slotLengthMs,\r\n  slotStepMs,\r\n  renderAvailSlots,\r\n  renderDayCell,\r\n  renderDayCells,\r\n}: Omit<Omit<AvailabilityCalendarProps, 'moment'>, 'theme'>) => {\r\n  const { moment, utils } = useCalendarContext();\r\n\r\n  // const classes = useStyles();\r\n  const [now] = useState<Date>(initialDate || new Date());\r\n  const [calRange, setCalRange] = useState<Range>(utils.monthRangeForDate(now));\r\n  const [date, setDate] = useState<Date>(now);\r\n\r\n  const lastCalRange = useRef<Range | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (lastCalRange.current !== calRange) {\r\n      onCalRangeChange && onCalRangeChange(calRange);\r\n      lastCalRange.current = calRange;\r\n    }\r\n  }, [calRange, onCalRangeChange]);\r\n\r\n  const availabilities = useMemo<\r\n    { startDate: Date; endDate: Date; resourceId: number }[]\r\n  >(() => {\r\n    const startAndEnd = utils.toStartAndEnd(calRange);\r\n    return (\r\n      // chunkify(\r\n      utils\r\n        .availabilitiesFromBookings(\r\n          blockOutPeriods || [],\r\n          providerTimeZone,\r\n          bookings,\r\n          now,\r\n          startAndEnd.startDate,\r\n          startAndEnd.endDate\r\n        )\r\n        // ,\r\n        //   1.5 * 60 * 60 * 1000\r\n        // )\r\n        .filter(\r\n          a =>\r\n            a.endDate.getTime() - a.startDate.getTime() > 0.5 * 60 * 60 * 1000\r\n        )\r\n        .map(interval => ({\r\n          resourceId: 2,\r\n          startDate: new Date(interval.startDate),\r\n          endDate: new Date(interval.endDate),\r\n        }))\r\n    );\r\n  }, [bookings, providerTimeZone, calRange, now, blockOutPeriods, utils]);\r\n\r\n  const handleOnNavigate = (navigate: NavigateAction) => {\r\n    if (navigate === 'TODAY') {\r\n      const today = new Date();\r\n      setDate(today);\r\n      setCalRange(utils.monthRangeForDate(today));\r\n      return;\r\n    }\r\n\r\n    if (navigate !== 'NEXT' && navigate !== 'PREV') return;\r\n\r\n    const newDate = moment(date)\r\n      .add(navigate === 'NEXT' ? 1 : -1, 'month')\r\n      .toDate();\r\n    setDate(newDate);\r\n\r\n    setCalRange(utils.monthRangeForDate(newDate));\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <Toolbar\r\n        onNavigate={handleOnNavigate}\r\n        label={utils.formatAsMonth(date)}\r\n        localizer={{\r\n          messages: { today: 'Today', previous: 'Previous', next: 'Next' },\r\n        }}\r\n      />\r\n      <MonthlyAvailabilityCalendar\r\n        availabilities={availabilities}\r\n        date={date}\r\n        onAvailabilitySelected={onAvailabilitySelected}\r\n        slotLengthMs={slotLengthMs}\r\n        slotStepMs={slotStepMs}\r\n        renderAvailSlots={renderAvailSlots}\r\n        renderDayCell={renderDayCell}\r\n        renderDayCells={renderDayCells}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport const AvailabilityCalendar = ({\r\n  moment,\r\n  theme,\r\n  ...props\r\n}: AvailabilityCalendarProps) => {\r\n  return (\r\n    <CalendarContextProvider\r\n      moment={moment}\r\n      theme={theme ? { ...defaultTheme, ...theme } : defaultTheme}\r\n    >\r\n      <AvailabilityCalendarComp {...props} />\r\n    </CalendarContextProvider>\r\n  );\r\n};\r\n","import React from 'react';\r\n\r\nimport {\r\n  AvailabilityCalendar,\r\n  AvailabilityEvent,\r\n  MsSinceMidnightRange,\r\n  Booking,\r\n  Range,\r\n  CalendarThemeProp,\r\n} from 'react-availability-calendar';\r\nimport moment from 'moment';\r\n\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport './custom.scss';\r\n\r\nconst msInHour = 60 * 60 * 1000;\r\n\r\nconst App: React.FC = () => {\r\n  const now = new Date();\r\n\r\n  const onAvailabilitySelected = (a: AvailabilityEvent) =>\r\n    console.log('Availability slot selected: ', a);\r\n\r\n  const onChangedCalRange = (r: Range) =>\r\n    console.log('Calendar range selected (fetch bookings here): ', r);\r\n\r\n  const blockOutPeriods: MsSinceMidnightRange[] = [\r\n    [0 * msInHour, 9 * msInHour],\r\n    [19 * msInHour, 24 * msInHour],\r\n  ];\r\n\r\n  const bookings: Booking[] = [\r\n    {\r\n      startDate: new Date(2020, 2, 1, 19),\r\n      endDate: new Date(2020, 2, 1, 20),\r\n    },\r\n    {\r\n      startDate: new Date(2020, 2, 1, 16, 30),\r\n      endDate: new Date(2020, 2, 1, 17),\r\n    },\r\n  ];\r\n\r\n  const providerTimeZone = 'America/New_York';\r\n\r\n  return (\r\n    <div style={{ width: 350 }}>\r\n      <AvailabilityCalendar\r\n        bookings={bookings}\r\n        providerTimeZone={providerTimeZone}\r\n        moment={moment}\r\n        initialDate={now}\r\n        onAvailabilitySelected={onAvailabilitySelected}\r\n        onCalRangeChange={onChangedCalRange}\r\n        blockOutPeriods={blockOutPeriods}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}